// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::anyhow;
use anyhow::Error as AppError;
use methods::{OAKSHIELD_ELF, OAKSHIELD_ID};
use mithril_dwarf::parser::byte_parser_writer::certificate_to_bytes_opt;
use mithril_dwarf::{
    CardanoTransactionsProofs, Certificate, Client, ClientBuilder, Ed25519VerificationKey,
    MithrilCertificate,
};
use risc0_zkvm::ProverOpts;
use risc0_zkvm::{default_prover, ExecutorEnv};

#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let network = Network::Mainnet;
    let genesis_key_string = network.get_genesis_key().to_string();

    let genesis_key = *Ed25519VerificationKey::try_from(genesis_key_string)
        .unwrap()
        .as_bytes();
    let tx_hash = "544ae8325a9e84865f5a1ca4a3346d9dbce0a5e23bca93b8f06ab4f24d04c331";
    let client = make_mithril_client(network).unwrap();
    let tx_proof = get_transaction_proof(&client, &tx_hash).await.unwrap();
    if tx_proof
        .non_certified_transactions
        .contains(&tx_hash.to_string())
    {
        //return Err(
        //    anyhow!("Transaction could not be certified, not found in aggregator, abort!").into(),
        //);
        panic!("Transaction could not be certified, not found in aggregator, abort!")
    }

    let certificate = get_certificate(&client, &tx_proof.certificate_hash)
        .await
        .unwrap()
        .ok_or(anyhow!(
            "No certificate found for {:?}",
            &tx_proof.certificate_hash
        ))
        .unwrap();

    let previous_cert = get_certificate(&client, &certificate.previous_hash)
        .await
        .unwrap()
        .ok_or(anyhow!(
            "No certificate found for {:?}",
            &certificate.previous_hash
        ))
        .unwrap();

    let c: Certificate = certificate.clone().try_into().unwrap();
    let parsed_bytes_opt = certificate_to_bytes_opt(&c);

    let p = previous_cert.clone().try_into().unwrap();
    let perv_cert_parsed_bytes_opt = certificate_to_bytes_opt(&p);

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let env = ExecutorEnv::builder()
        .write_slice(&genesis_key)
        .write(&parsed_bytes_opt.len())
        .unwrap()
        .write_slice(&parsed_bytes_opt)
        .write(&perv_cert_parsed_bytes_opt.len())
        .unwrap()
        .write_slice(&perv_cert_parsed_bytes_opt)
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();
    //let prove_ops = ProverOpts::groth16();
    let prove_ops = ProverOpts::succinct();
    let prove_info = prover
        .prove_with_opts(env, OAKSHIELD_ELF, &prove_ops)
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    //let _output: u32 = receipt.journal.decode().unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(OAKSHIELD_ID).unwrap();
}

// Helper functions
pub(crate) fn make_mithril_client(network: Network) -> Result<Client, AppError> {
    ClientBuilder::aggregator(network.get_aggregator_url(), network.get_genesis_key())
        .build()
        .map_err(|e| e.into())
}

pub(crate) async fn get_transaction_proof(
    client: &Client,
    tx_hash: &str,
) -> Result<CardanoTransactionsProofs, AppError> {
    client
        .cardano_transaction()
        .get_proofs(&[tx_hash])
        .await
        .map_err(|e| e.into())
}

pub(crate) async fn get_certificate(
    client: &Client,
    certificate_hash: &str,
) -> Result<Option<MithrilCertificate>, AppError> {
    client
        .certificate()
        .get(certificate_hash)
        .await
        .map_err(|e| e.into())
}

#[derive(Debug)]
pub enum Network {
    Preview,
    Preprod,
    Mainnet,
}

impl Network {
    pub fn get_genesis_key(&self) -> &str {
        match self {
            Self::Preview => {
                "5b3132372c37332c3132342c3136312c362c3133372c3133312c3231332c3230372c3131372c3139382c38352c3137362c3139392c3136322c3234312c36382c3132332c3131392c3134352c31332c3233322c3234332c34392c3232392c322c3234392c3230352c3230352c33392c3233352c34345d"
            }
            Self::Preprod => {
                "5b3132372c37332c3132342c3136312c362c3133372c3133312c3231332c3230372c3131372c3139382c38352c3137362c3139392c3136322c3234312c36382c3132332c3131392c3134352c31332c3233322c3234332c34392c3232392c322c3234392c3230352c3230352c33392c3233352c34345d"
            }
            Self::Mainnet => {
                "5b3139312c36362c3134302c3138352c3133382c31312c3233372c3230372c3235302c3134342c32372c322c3138382c33302c31322c38312c3135352c3230342c31302c3137392c37352c32332c3133382c3139362c3231372c352c31342c32302c35372c37392c33392c3137365d"
            }
        }
    }

    pub fn get_aggregator_url(&self) -> &str {
        match self {
            Self::Preview => {
                "https://aggregator.pre-release-preview.api.mithril.network/aggregator"
            }
            Self::Preprod => "https://aggregator.release-preprod.api.mithril.network/aggregator",
            Self::Mainnet => "https://aggregator.release-mainnet.api.mithril.network/aggregator",
        }
    }
}
